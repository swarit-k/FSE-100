% Set up EV3 connection
% myev3 = legoev3('usb');
lM = motor(brick, A); % Left motor
rM = motor(brick, B); % Right motor
sM = motor(brick, D); % Scanning motor for ultrasonic
gs = gyroSensor(brick, 1); % Gyro sensor
cs = colorSensor(brick, 2); % Light sensor
ts = touchSensor(brick, 3); % Touch sensor
us = sonicSensor(brick, 4); % Ultrasonic sensor

% Parameters
stopDistance = 60;
slowDistance = stopDistance + 30;
fastForwardSpeed = -50;
slowForwardSpeed = -20;
turnSpeed = 30; % Motors in reverse
turnLeftAngle = -90;
turnRightAngle = 90;
useGyro = true;

% Function to get front distance
function frontDistance = getFrontDistance(us, ls)
    frontDistance = readDistance(us); % Convert meters to cm
    %{
    if frontDistance == 255
        frontDistance = 0;
    end
    %}
end

% Function to get left and right distances by moving motor C
function [leftDistance, rightDistance] = getLeftRightDistance(us, sM)
    % Measure left distance
    start(sM, -50); % Rotate motor C to left position
    pause(1);
    leftDistance = readDistance(us); % Convert meters to cm
    %{
    if leftDistanceCm == 255
        leftDistanceCm = 0;
    end
    %}
    stop(sM);
    
    % Measure right distance
    start(sM, 50); % Rotate motor C to right position
    pause(1);
    rightDistanceCm = readDistance(us); % Convert meters to cm
    %{
    if rightDistanceCm > 255
        rightDistanceCm = 0;
    end
    %}
    stop(sM);
end

% Function to turn left
function turnLeft(lM, rM, gyro, useGyro)
    if useGyro
        startAngle = readRotationAngle(gyro);
        mA.Speed = turnSpeed;
        mB.Speed = -turnSpeed;
        start(mA); start(mB);
        while readRotationAngle(gyro) - startAngle > turnLeftAngle
            % Keep turning
        end
    else
        mA.Speed = turnSpeed;
        mB.Speed = -turnSpeed;
        start(mA); start(mB);
        pause(1.13); % Use timing if gyro is not used
    end
    stop(mA); stop(mB);
end

% Function to turn right
function turnRight(mA, mB, gyro, useGyro)
    if useGyro
        startAngle = readRotationAngle(gyro);
        mA.Speed = -turnSpeed;
        mB.Speed = turnSpeed;
        start(mA); start(mB);
        while readRotationAngle(gyro) - startAngle < turnRightAngle
            % Keep turning
        end
    else
        mA.Speed = -turnSpeed;
        mB.Speed = turnSpeed;
        start(mA); start(mB);
        pause(1.18); % Use timing if gyro is not used
    end
    stop(mA); stop(mB);
end

% Main logic loop
isMoving = true;
mA.Speed = fastForwardSpeed;
mB.Speed = fastForwardSpeed;
start(mA); start(mB);

while true
    % Check front distance
    frontDistanceCm = getFrontDistance(uss, ls);

    % End of the maze (based on light sensor threshold)
    light = readLightIntensity(ls, 'reflected');
    if light < 5
        stop(mA); stop(mB);
        disp("End of Maze");
        break;
    end
    
    % Move slower as it approaches an obstacle
    while frontDistanceCm > slowDistance
        frontDistanceCm = getFrontDistance(uss, ls);
    end
    mA.Speed = slowForwardSpeed;
    mB.Speed = slowForwardSpeed;
    start(mA); start(mB);
    
    % Stop if an obstacle is too close
    while frontDistanceCm > stopDistance
        frontDistanceCm = getFrontDistance(uss, ls);
    end
    stop(mA); stop(mB);
    
    % Check left and right distances
    [leftDistanceCm, rightDistanceCm] = getLeftRightDistance(uss, mC);

    % Choose turning direction
    if leftDistanceCm > rightDistanceCm
        turnLeft(mA, mB, gyro, useGyro);
    else
        turnRight(mA, mB, gyro, useGyro);
    end
    
    % Resume moving forward
    mA.Speed = fastForwardSpeed;
    mB.Speed = fastForwardSpeed;
    start(mA); start(mB);
end 


